#include "stdafx.hpp"

#include "snake_overflow/invulnerability_spell.hpp"
#include "snake_overflow/testing/cube_terrain_game_fixture.hpp"
#include "util/repeat.hpp"

namespace snake_overflow { namespace testing
{

class InvulnerabilitySpell : public CubeTerrainGameFixture
{

protected:

    virtual void SetUp() override
    {
        CubeTerrainGameFixture::SetUp();

        this->the_spell = std::make_unique<invulnerability_spell>(
            this->lifetime);
    }

protected:

    int lifetime = 5;

    std::unique_ptr<invulnerability_spell> the_spell;

};

TEST_THAT(InvulnerabilitySpell,
     WHAT(Affect),
     WHEN(GivenASnakeToWhichTheSpellWasAdded),
     THEN(MakesItInvulnerableForANumberOfUpdatesEqualToTheLifetimeOfTheSpell))
{
    auto& s = get_snake();

    auto added_spell = this->the_spell.get();

    s.add_spell(std::move(this->the_spell));

    util::repeat(this->lifetime - 1, [added_spell, &s]
    {
        added_spell->affect(s);
        EXPECT_TRUE(s.invulnerability_bonus);
    });

    added_spell->affect(s);
    EXPECT_FALSE(s.invulnerability_bonus);
}

TEST_THAT(InvulnerabilitySpell, 
    WHAT(Affect),
    WHEN(WhenTheLifetimeOfTheSpellReachesZero),
    THEN(RemovesSelfFromTheSnake))
{
    auto& s = get_snake();

    auto added_spell = this->the_spell.get();

    s.add_spell(std::move(this->the_spell));

    util::repeat(this->lifetime, [added_spell, &s]
    {
        added_spell->affect(s);
    });

    auto const spells = s.get_all_spells();

    EXPECT_TRUE(spells.empty());
}

} }